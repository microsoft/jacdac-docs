{"componentChunkName":"component---src-templates-service-tsx","path":"/services/bootloader/","result":{"pageContext":{"classIdentifier":536516936,"source":"# Bootloader\n\n    identifier: 0x1ffa9948\n    tags: C, management\n    status: stable\n\nAllows flashing (reprogramming) devices over Jacdac.\n\nThis is typically implemented by having a separate _bootloader_ mode, as opposed to _application_ mode\non the module to be flashed.\nThe bootloader mode is entered on every device reset, for about 300ms.\nThe bootloader will generally not announce itself, until it gets some command.\nOnce it gets the command, it will stay in application mode.\n\nTypically, you ask the module (in application mode) to reset, while sending broadcast\n`info` commands to all bootloaders every 100ms or so.\nAlternatively, you ask the the user to disconnect and re-connect the module, while\nbroadcasting `info` commands.\nThe second method works even if the application is damaged (eg., due to an aborted flash).\n\nWhen device is in bootloader mode, the device ID may change compared to application mode,\nby flipping the first bit in the first byte of the device identifier.\n\n## Commands\n\n    command info @ announce { }\n    report {\n        service_class: u32\n        page_size: u32 B\n        flashable_size: u32 B\n        product_identifier: u32\n    }\n\nThe `service_class` is always `0x1ffa9948`. The `product_identifier` identifies the kind of firmware\nthat \"fits\" this device.\n\n    command set_session @ 0x81 {\n        session_id: u32\n    }\n    report {\n        session_id: u32\n    }\n\nThe flashing server should generate a random id, and use this command to set it.\n\n    enum Error : u32 {\n        NoError = 0\n        PacketTooSmall = 1\n        OutOfFlashableRange = 2\n        InvalidPageOffset = 3\n        NotPageAligned = 4\n    }\n    unique command page_data @ 0x80 {\n        page_address: u32\n        page_offset: u16\n        chunk_no: u8\n        chunk_max: u8\n        session_id: u32\n        reserved0: u32\n        reserved1: u32\n        reserved2: u32\n        reserved3: u32\n        page_data: bytes { max_bytes = 208}\n    }\n    report {\n        session_id: u32\n        page_error: Error\n        page_address: u32\n    }\n\nUse to send flashing data. A physical page is split into `chunk_max + 1` chunks, where `chunk_no = 0 ... chunk_max`.\nEach chunk is stored at `page_address + page_offset`. `page_address` has to be equal in all chunks,\nand is included in response.\nOnly the last chunk causes writing to flash and elicits response.\n\nErrors not listed are also possible. Errors larger than `0xffff` indicate de-synchronization on chunk numbers.\n\nWhile this command is technically `unique`, the bootloader client will retry failed pages.\nBootloaders typically will not support reliable commands delivered over pipes.\n","title":"Bootloader"}},"staticQueryHashes":["1089213825","2744294623","3360859391","3610498499","3868184074","4022945823","413816803","63159454"]}